#!/bin/bash

#export DEBUG=true

get_region() {
    grep -w $1 ${TOOL_CONFIG}/AccountMapping.lst | head -1 | cut -d " " -f 1
}

# Setup Environment for specific DATA_SET
export DATA_SET=Bloomberg
export OBJECT_TYPES=("Instant Bloomberg" "Bloomberg Messenger")
unset SUBSET_NAME
. `dirname $0`/config/envsetup

# Only allow one instance for a given config at a time.
get_lock

# Initialize Counters
init_report_counters

ExitCode=$EXIT_SUCCESS  # Assume the best
ExitMessage="(none)"

# Make sure we have files
STAGING_FOLDER="${STAGING_AREA}"
if [ ! -d "${STAGING_FOLDER}" ]; then
    ExitCode=$EXIT_ERROR

    report_status $ExitCode "ERROR: Staging Folder (${STAGING_FOLDER}) does not exist."

    exit $ExitCode;
fi
STAGING_FOLDER=`readlink -e "${STAGING_FOLDER}"`

echo "INFO: [${DATA_SET}] Starting Processing"
log_timestamp

#
# Setup folders/files and variables to them.
#
mkdir -p ${PROCESSING_AREA} ${QUARANTINE_AREA}

RAW_FOLDER=`readlink -e ${PROCESSING_AREA}`/${RAW_NAME}
TRANSFORM_FOLDER=`readlink -e ${PROCESSING_AREA}`/${TRANSFORM_NAME}
FAILURE_FOLDER=`readlink -e ${QUARANTINE_AREA}`

PROCESSING_LOG=`readlink -e ${PROCESSING_AREA}`/history.log

mkdir -p ${RAW_FOLDER} ${TRANSFORM_FOLDER}

rm -rf ${TOOL_TMP} # Start fresh
mkdir -p ${TOOL_TMP}

if [ `ls "${STAGING_FOLDER}" | wc -l` -lt 1 ]; then
   ExitCode=$EXIT_WARNING
   ExitMessage="No files found in staging area: ${STAGING_FOLDER}"

   echo "WARN: $ExitMessage"
   log_timestamp
else

    ##
    # Collect full collection(s) from staging area and place in RAW_FOLDER area
    ##
    [ ! -z "$DEBUG" ] && echo "DEBUG: Performing data set collection from: ${STAGING_FOLDER}"

    TMP_COLLECT_FILE=${TOOL_TMP}/`basename $0`.$$

    ${TOOL_HOME}/Collect${DATA_SET} ${STAGING_FOLDER} ${RAW_FOLDER} ${FAILURE_FOLDER} | tee $TMP_COLLECT_FILE

    collectWarnings=`grep "WARN:" $TMP_COLLECT_FILE | wc -l`
    ((CollectFileWarningCount+=${collectWarnings}))
    collectErrors=`grep "ERROR:" $TMP_COLLECT_FILE | wc -l`
    ((CollectFileFailureCount+=${collectErrors}))

    rm -f ${TMP_COLLECT_FILE}

    if [ 0 != $CollectFileWarningCount ]; then
      ExitCode=$EXIT_WARNING
      ExitMessage="Detected Warning(s) during file collection from: ${STAGING_FOLDER}"
    fi
    if [ 0 != $CollectFileFailureCount ]; then
      ExitCode=$EXIT_ERROR
      ExitMessage="Detected Error(s) during file collection from: ${STAGING_FOLDER}"
    fi
fi

##
# For all the complete collections we grabbed, it is time to process them.
##
pushd "${RAW_FOLDER}" > /dev/null

for oneRegion in `ls -d * 2> /dev/null`; do
    if [ ! -d "$oneRegion" ]; then
       echo "WARN: Found non-directory file in Processing area. Ignored. ($oneRegion)"

       continue
    fi

    # Head down into region and process next level.
    pushd "${oneRegion}" > /dev/null
 
    for oneAccount in `ls -d * 2> /dev/null`; do

        if [ ! -d "$oneAccount" ]; then
           echo "WARN: Found non-directory file in region folder. Ignored. ($oneAccount)"

           continue
        fi

        ###
        ### Prepare Raw Files
        ###
        echo "INFO: [${DATA_SET}/${oneRegion}/${oneAccount}] Starting Processing"
        log_timestamp

        pushd "${oneAccount}" > /dev/null

        # Now process each of the collection folder for this region.
        for collectionFolder in `ls -d * 2> /dev/null`; do

            # Only process folders at this level.
            if [ ! -d "$collectionFolder" ]; then
               echo "WARN: Found non-directory file in Account folder. Ignored. ($collectionFolder)"

               continue
            fi

            echo "INFO: [${DATA_SET}/${oneRegion}/${oneAccount}/${collectionFolder}] Validating Raw Folder"
            log_timestamp

            ${TOOL_HOME}/Validate${DATA_SET} "${collectionFolder}" "${TOOL_TMP}"
     
            # Only continue processing this collection if successful.  Otherwise try to process the next one.
            if [ $? != 0 ]; then
              ExitMessage="Validation Failed. Moving $oneRegion/${oneAccount}/$collectionFolder to Failure folder" 
              echo "ERROR: $ExitMessage"

              pushd ${TOOL_HOME} > /dev/null
              mkdir -p ${FAILURE_FOLDER}/${RAW_NAME}/${oneRegion}/${oneAccount}
              # Note: Not just moving folder because there might be one already existing from prior failures.
              ${TOOL_HOME}/doCopy -fr ${RAW_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder} ${FAILURE_FOLDER}/${RAW_NAME}/${oneRegion}/${oneAccount}
              rm -fr ${RAW_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder}
              popd > /dev/null

              ((ValidationFailureCount++))
              ExitCode=$EXIT_ERROR
  
              continue;
            fi

            # Compute Checksum of collection.
            checkSumString="${oneRegion}/${oneAccount}/${collectionFolder} `cat ${collectionFolder}/daily_manifest_*.txt`"
            collectionCheckSum=`echo -n "${checkSumString}" | sha1sum | cut -d " " -f 1`

            # First see if we have seen this one yet.
            LogEntry=`cut -d "," -f 2 ${PROCESSING_LOG} 2>/dev/null | grep ${collectionCheckSum}`
            if [ ! -z "${LogEntry}" ]; then
                echo "ERROR: Collection checksum found: ${collectionCheckSum}"
                ExitMessage="Found collection already processed: ${oneRegion}/${oneAccount}/${collectionFolder}"
                echo "ERROR: $ExitMessage"

                mkdir -p ${FAILURE_FOLDER}/${RAW_NAME}/${oneRegion}/${oneAccount}
	        if [ -d "${FAILURE_FOLDER}/${RAW_NAME}/${oneRegion}/${oneAccount}/${collectionFolder}" ]; then
                    # Seems we have seen this a few times.  Keep the older one.
                    rm -rf ${RAW_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder}
                else
                    # Copy/Delete what we found to the failure area.
                    # Note: Not just moving folder because there might be one already existing from prior failures.
                    ${TOOL_HOME}/doCopy -fr ${RAW_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder} ${FAILURE_FOLDER}/${RAW_NAME}/${oneRegion}/${oneAccount}
                    rm -rf -fr ${RAW_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder}
                fi

                ((DuplicateFailureCount++))
                ExitCode=$EXIT_WARNING

                continue;  # Don't do anymore with this one.
            fi

            # Record that we saw this one.
            echo "`date "+%Y %m %d %H %M %S"`,${collectionCheckSum},${oneRegion}/${oneAccount}/${collectionFolder}" >> ${PROCESSING_LOG}

            ###
            ### Prepare Transform files.
            ###
            echo "INFO: [${DATA_SET}/${oneRegion}/${oneAccount}/${collectionFolder}] Preparing Transform Folder"
            log_timestamp

            mkdir -p ${TRANSFORM_FOLDER}/${oneRegion}/${oneAccount}
            ${TOOL_HOME}/doCopy -fr ${RAW_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder} ${TRANSFORM_FOLDER}/${oneRegion}/${oneAccount}
   
            ## TODO
            ## TODO: Need error handling for all these operations. :-(
            ## TODO

            pushd "${TRANSFORM_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder}" > /dev/null

            # First, rename most things.  There should only be one of each type at this level.
            find . -name "*.att.*.tar.gz" -exec mv {} attachments.tar.gz \;
            find . -name "*.msg.*.xml" -exec mv {} messages.xml \;
            find . -name "*.ib.*.xml" -exec mv {} conversations.xml \;
            find . -name "*.dscl.*.xml" -exec mv {} disclaimers.xml \;
            rm -f daily_manifest_*.txt  # This isn't useful, so remove

            numAttachments=0
            if [ -f attachments.tar.gz ]; then
                log_timestamp "Starting attachment file expansion"
                mkdir -p attachments
                tar xzf attachments.tar.gz -C attachments --strip-components=1 && rm attachments.tar.gz

                numAttachments=`ls attachments | wc -l`
            fi
            echo "INFO: [${DATA_SET}/${oneRegion}/${oneAccount}/${collectionFolder}] Number Attachments: ${numAttachments}"
            log_timestamp

            numMessages=0
            if [ -f messages.xml ]; then
                ${TOOL_HOME}/XMLTagExtractor Version messages.xml -q -f -o - | grep -v "^$" | grep -v "<?xml" > Version.xml

                # Tally up how many Messages found.
                numMessages=`${TOOL_HOME}/XMLTagExtractor MsgID messages.xml -m -q -f -o - | grep -v "^$" | grep -v "<?xml" | wc -l`

                # Perform Transform to add dataType attributes.
                ${TOOL_HOME}/doCopy messages.xml "${XSLT_TMP_FILE}"
                ${TOOL_HOME}/XSLTRun -xsl:${TOOL_CONFIG}/TransformMessage.xslt -s:${XSLT_TMP_FILE} -o:messages.xml
                if [ $? -ne 0 ]; then
                    ExitMessage="Failed to add data types to messages.xml file"
                    ExitCode=$EXIT_WARNING

                    echo "WARN: $ExitMessage"
                    mv -f ${MV_CP_CMD_OPT} "${XSLT_TMP_FILE}" messages.xml
                else
                    rm -f "${XSLT_TMP_FILE}"
                fi
            fi
            echo "INFO: [${DATA_SET}/${oneRegion}/${oneAccount}/${collectionFolder}] Number Messages: ${numMessages}"
            log_timestamp

            numConversations=0
            if [ -f conversations.xml ]; then 
                ${TOOL_HOME}/doCopy conversations.xml "${XSLT_TMP_FILE}"
                ${TOOL_HOME}/XSLTRun -xsl:${TOOL_CONFIG}/TransformConversation.xslt -s:${XSLT_TMP_FILE} -o:conversations.xml
                if [ $? -ne 0 ]; then
                    ExitMessage="Failed to add data types to Conversation: ${DATA_SET}/${oneRegion}/${oneAccount}/${collectionFolder}"
                    ExitCode=$EXIT_WARNING

                    echo "WARN: $ExitMessage"
                    mv -f ${MV_CP_CMD_OPT} "${XSLT_TMP_FILE}" conversations.xml
                else
                    rm -f "${XSLT_TMP_FILE}"
                fi
                mkdir -p conversations

                pushd conversations > /dev/null

                # Break a part the conversations.xml into pieces.
                ${TOOL_HOME}/XMLTagExtractor Version ../conversations.xml -q -f
                collDate=`echo "${collectionFolder}" | cut -d 'T' -f 1`
                fnameDate=`date -d "$collDate" +%y%m%d`
                ConversationPrefix="${BLMIB_FNAME_PREFIX}${fnameDate}"
                ${TOOL_HOME}/XMLTagExtractor Conversation ../conversations.xml -o "$ConversationPrefix" -m -q -f

                # Tally up how many Conversations Items found.
                numConversations=`find . -name "${BLMIB_FNAME_PREFIX}*.xml" | wc -l`

                popd > /dev/null

                rm conversations.xml
            fi
            echo "INFO: [${DATA_SET}/${oneRegion}/${oneAccount}/${collectionFolder}] Number Conversations: ${numConversations}"
            log_timestamp

            ##
            ## Distibute Firm-Wide to individual accounts.
            ##
            #
            # Now that we have the first level firm-wide transform, need to process this
            #   into individual region/legal-entity area(s)


            ##
            ## PROCESS MESSAGES
            ##
            if [ -f messages.xml ]; then
                echo "INFO: Processing ${numMessages} Messages in: ${TRANSFORM_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder}"
                log_timestamp

                # Perform the message split out. This will also copy the attachments.
                export XMLPROCESSOR_DEFINES="-Dlog4j.configurationFile=${TOOL_CONFIG}/log4j2_BLMXMLTagProcessor.xml -Dnl.rabobank.tools.xmlprocessor.properties.file=${TOOL_CONFIG}/XMLTagProcessor.properties"
                BLM_XARGS="collection-date=${collectionFolder},source-attachments-folder=attachments,destination-root-folder=${TRANSFORM_FOLDER}"
                collDate=`echo "${collectionFolder}" | cut -d 'T' -f 1`
                fnameDate=`date -d "$collDate" +%y%m%d`
                MessageFilePrefix="${BLMMSG_FNAME_PREFIX}${fnameDate}"
                ${TOOL_HOME}/XMLTagExtractor Message messages.xml -f -q -m -o "$MessageFilePrefix" -p nl.rabobank.tools.BlmIMXMLTagToFilesProcessorImpl -x "${BLM_XARGS}"

                # Distribute Version.xml to all messages folders
                [ -f Version.xml ] \
                     && find ${TRANSFORM_FOLDER} -name "messages" -type d -exec ${TOOL_HOME}/doCopy -n Version.xml {} \;

                # Generate attachment metadata for those messages that have them.
                find ${TRANSFORM_FOLDER} -name "${BMLMSG_FNAME_PREFIX}*.xml" | while read oneMessage; do
                    # If this message has an attachment tag, then generate attachment info.
                    grep -q "<Attachment>" $oneMessage 
                    if [ 0 -eq $? ]; then

                        [ ! -z "$DEBUG" ] && echo "DEBUG: Generating Attachment Metadata for message: ${oneMessage}"

                        #Transform Message attachment Metadata and save it with .att file extension
                        outputMessageMetadataFilename="`dirname ${oneMessage}`/`basename ${oneMessage} | cut -d "." -f 1`"
                        ${TOOL_HOME}/XSLTRun -xsl:${TOOL_CONFIG}/TransformMessageAttMetadata.xslt -s:${oneMessage} \
                             -o:${outputMessageMetadataFilename}.${ATT_METADATA_FILE_EXT}
                    fi
                done
            fi

            ##
            ## PROCESS CONVERSATIONS
            ##
            if [ -d conversations ]; then
                echo "INFO: Processing ${numConversations} conversations in: ${TRANSFORM_FOLDER}/${oneRegion}/${oneAccount}/${collectionFolder}"
                log_timestamp

                # Create a scratch area
                rm -rf scratch.$$
                mkdir -p scratch.$$
                SCRATCH_AREA="`readlink -e scratch.$$`"
                CONVERSATION_WORKAREA="${SCRATCH_AREA}/conversations"
                mkdir -p "${CONVERSATION_WORKAREA}"

                TMP_LOOKUP_FOLDER="${SCRATCH_AREA}/lookup"
                mkdir -p "${TMP_LOOKUP_FOLDER}"

                # Process each conversation in order by the number part of the name
                pushd conversations > /dev/null
                for oneConversation in `ls ${BLMIB_FNAME_PREFIX}*.xml 2>/dev/null | sort -n -t "_" -k 2`; do
                    if [ ! -z "$DEBUG" ]; then
                        echo "DEBUG: Processing $oneConversation"
                        log_timestamp
                    fi
 
                    # Clean up any residual files from prior conversation
                    rm -rf ${CONVERSATION_WORKAREA}/* ${TMP_LOOKUP_FOLDER}/* 2>&1 > /dev/null

                    [ ! -z "$DEBUG" ] && echo "DEBUG: Building Conversation Files in folder: $CONVERSATION_WORKAREA"

                    conversationFile=`readlink -e $oneConversation`

                    #
                    # Put the conversation file into the work area.
                    #
                    ${TOOL_HOME}/doCopy -f $conversationFile ${CONVERSATION_WORKAREA}/

                    #
                    # Build up information about this conversation for later processing.
                    #

                    # Retrieve the list of Attachments in this conversation, we'll use it below
                    attachList=`${TOOL_HOME}/XMLTagExtractor FileID ${conversationFile} -m -q -f -o - | grep -v "^$" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -u`
                    [ ! -z "$DEBUG" ] && echo "DEBUG: Found Attachments: ${attachList}"

                    # Retrieve all the unique AccountNumbers in this Conversation
                    acctList=`${TOOL_HOME}/XMLTagExtractor AccountNumber ${conversationFile} -m -q -o - | grep -v "^$" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -n -u`
                    [ ! -z "$DEBUG" ] && echo "DEBUG: Found Account List: ${acctList}"
                    if [ -z "$acctList" ]; then
                        echo "WARN: Found Conversation without any AccountNumber(s): ${oneConversation}"
                        acctList="${UNKNOWN_ACCOUNT_VALUE}"
                    fi

                    [ ! -z "$DEBUG" ] && echo "DEBUG: Looking to see if one account is known"
                    haveOneKnownAccount=0
                    for oneAcct in $acctList; do
                        if [ ! -z "`get_region ${oneAcct}`" ]; then
                            haveOneKnownAccount=1
                            break;
                        fi
                    done
  
                    # Going to need the Attachment tag files in the loop.  Do once now.
                    pushd "${TMP_LOOKUP_FOLDER}" > /dev/null
                    ${TOOL_HOME}/XMLTagExtractor Attachment "${conversationFile}" -i FileID -f -m -q
                    popd > /dev/null

                    #
                    # Build up all metadata files into the work area
                    #
                    pushd "${CONVERSATION_WORKAREA}" > /dev/null

                    # Create the sister "_Metadata" file that will be used to create custom metadata for the conversation
                    ${TOOL_HOME}/XSLTRun -s:$conversationFile -xsl:${TOOL_CONFIG}/CollectIBUsers.xslt \
                            -o:`basename ${conversationFile}`${METADATA_FILE_POSTFIX}

                    #Transform Conversation to generate Conversation attachment Metadata and save it with .att extension
                    if [ ! -z "$attachList" ]; then
                      [ ! -z "$DEBUG" ] && log_timestamp "Starting XSLTRun(TransformConversationAttMetadata.xslt) against conversation $oneConversation"

                      outputFile=`echo ${oneConversation} | cut -d "." -f 1`
                      ${TOOL_HOME}/XSLTRun -xsl:${TOOL_CONFIG}/TransformConversationAttMetadata.xslt -s:${conversationFile} \
                             -o:$outputFile.${ATT_METADATA_FILE_EXT}

                      [ ! -z "$DEBUG" ] && log_timestamp "Finishing XSLTRun(TransformConversationAttMetadata.xslt) against conversation $oneConversation"
                    fi
                        
                    popd > /dev/null

                    # For each Account found, assemble the full conversation just built up with attachment info
                    #   If Version.xml does exist, also put that there.
                    for oneAcct in $acctList; do
                        [ ! -z "$DEBUG" ] && echo "DEBUG: Looking up region for account $oneAcct"
                        destRegion=`get_region ${oneAcct}`

                        # Was there no region for this account? 
	    		if [ -z "${destRegion}" ]; then
                           #
                           # No known region for account, so need to put it in the Unknown region.
                           #    If any users claim to be part of the the data set firm number,
                           #      put it in the "No Mapping" Region
                           #    If no users are part of the data set firm,
                           #      not going to ingest it so it will be left around as a residual.
                           #
                           destRegion="${UNKNOWN_REGION_NAME}"

                           # Get all the Invitee/Inviter/User tags that contain the AccountNumber/FirmNumber
                           pushd "${TMP_LOOKUP_FOLDER}" > /dev/null
                           ${TOOL_HOME}/XMLTagExtractor Invitee "${conversationFile}" -i AccountNumber -f -m -q
                           find . -name "Invitee*.xml" ! -name "Invitee_${oneAcct}.xml" -delete # Keep usage under control
                           ${TOOL_HOME}/XMLTagExtractor Inviter "${conversationFile}" -i AccountNumber -f -m -q
                           find . -name "Inviter*.xml" ! -name "Inviter_${oneAcct}.xml" -delete # Keep usage under control
                           ${TOOL_HOME}/XMLTagExtractor User "${conversationFile}" -i AccountNumber -f -m -q
                           find . -name "User*.xml" ! -name "User_${oneAcct}.xml" -delete # Keep usage under control
                           popd > /dev/null

                           # Look in the temp user files if the firm for the given account is our firm
                           cat ${TMP_LOOKUP_FOLDER}/*_${oneAcct}.xml 2>/dev/null \
                               | grep "<FirmNumber>" | cut -d ">" -f 2 | cut -d "<" -f 1 | grep "^${DATASET_FIRM_NUMBER}$" > /dev/null
                           if [ $? -eq 0 ];then
                               echo "WARN: Found an unknown account ($oneAcct) with our firm number ($DATASET_FIRM_NUMBER)"

                               destRegion="${NO_MAPPING_REGION_NAME}"
                           else
                               # We have an account that isn't ours, if we have one known account, 
                               #   Don't create a copy for the account.
                               if [ $haveOneKnownAccount -eq 1 ]; then
                                  [ ! -z "$DEBUG" ] && echo "DEBUG: Not creating account ($oneAcct) copy as it is not needed"
                  
                                  continue; # Toss it.
                               else
                                   echo "WARN: Failed to find region for account $oneAcct"
                               fi
                           fi

                           rm -f ${TMP_LOOKUP_FOLDER}/*_${oneAcct}.xml

                           # If it is our own, we want to still distribute to unknown because it is an exception.
                        fi

                        #
                        # Whatever region we determined for the current account, process it now.
                        #
                        destFolder="${TRANSFORM_FOLDER}/${destRegion}_data/${oneAcct}/${collectionFolder}"
                        mkdir -p ${destFolder}/conversations
                       
                        ${TOOL_HOME}/doCopy -f ${CONVERSATION_WORKAREA}/* ${destFolder}/conversations/
                        ${TOOL_HOME}/doCopy -f Version.xml ${destFolder}/conversations/

                        # If we have some for this conversation, move all the attachments for this chat
                        #     into the current account.
                        if [ ! -z "$attachList" ]; then
                            mkdir -p ${destFolder}/attachments

                            for oneAttach in $attachList; do
                                ${TOOL_HOME}/doCopy -f ../attachments/${oneAttach} ${destFolder}/attachments/

                                # For readability put in variables.
                                srcAttMetadataFile="${TMP_LOOKUP_FOLDER}/Attachment_${oneAttach}.xml"
                                dstAttMetadataFile="${destFolder}/attachments/${oneAttach}${METADATA_FILE_POSTFIX}"
                                if [ ! -f "${srcAttMetadataFile}" ]; then
                                    echo "WARN: Did not find expected temporary attachment metadata file: ${srcAttMetadataFile}"
                                    continue;  // Go to next.
                                fi

                                # If we don't already have a metadata file, create the top tab in the file.
                                if [ ! -f "$dstAttMetadataFile" ]; then
                                       printf "<${MSGATT_METADATA_TAG}>\n" > "${dstAttMetadataFile}"
                                fi

                                # Strip of trailing metadata tag as we'll put it back on later.
                                sed -i -e "/<\/${MSGATT_METADATA_TAG}>/d" "${dstAttMetadataFile}"

                                # Build the "Conversation" wrapper for this attachment reference.
                                echo "<Conversation>" >> ${dstAttMetadataFile}
                                echo "<HCPReference>conversations/${oneConversation}</HCPReference>" >> ${dstAttMetadataFile}
                                cat "${srcAttMetadataFile}" | grep -v "^<?xml" >> "${dstAttMetadataFile}"
                                echo "</Conversation>" >> ${dstAttMetadataFile}

                                # Put closing metadata tag.
                                echo "</${MSGATT_METADATA_TAG}>" >> ${dstAttMetadataFile}
                            done
                        fi
                    done # for oneAcct
                done # for oneConversation

                popd > /dev/null

                rm -rf ${SCRATCH_AREA} 2>&1 > /dev/null
            fi

            # Make copy of disclaimers.xml file into collection folders. Intentionally capitalizing file.
            [ -f disclaimers.xml ] \
                && find ${TRANSFORM_FOLDER} -type d -name "${collectionFolder}" -exec ${TOOL_HOME}/doCopy -n disclaimers.xml {}/Disclaimers.xml \;

            popd > /dev/null
        done  # End for collectionFolder

        popd > /dev/null
    done # for each Account

    popd > /dev/null

    # Remove the whole region as this is just a temporary one to construt all the others.
    [ ! -z "$DEBUG" ] \
       && echo "DEBUG: Removing firm-wide collection: ${TRANSFORM_FOLDER}/${oneRegion}"
    rm -rf "${TRANSFORM_FOLDER}/${oneRegion}"

done # End for region

popd > /dev/null

###
### Set ItemsProcessed with the number of Conversations found and messages in messages.xml files
###   Note: not doing this in the loop above, because it might not execute because we are 
###      reprocessing content already in WorkArea.
###    

# Tally up how many Conversations Items found.
numConversations=`find ${TRANSFORM_FOLDER} -name "${BLMIB_FNAME_PREFIX}*.xml" | wc -l`

((ItemsProcessed[0]+=${numConversations}))


# Tally up how many Messages found.
numMessages=`find ${TRANSFORM_FOLDER} -name "${BLMMSG_FNAME_PREFIX}*.xml" | wc -l`

((ItemsProcessed[1]+=${numMessages}))

###
### Ingest Raw into HCP
###
echo "INFO: [${DATA_SET}] Ingesting Raw Content into HCP"
log_timestamp

${TOOL_HOME}/runComet ${DATA_SET} Raw

###
### Ingest Tranformed into HCP
###
echo "INFO: [${DATA_SET}] Ingesting Transformed Content into HCP"
log_timestamp

${TOOL_HOME}/runComet ${DATA_SET} Transform

###
### Look for unexpected files left behind.  Cleanup where necessary.
###
echo "INFO: [${DATA_SET}] Looking for residual files and cleaning up"
log_timestamp

#
# First look at Raw files for residual files.
#
orphanFileCount=`find ${RAW_FOLDER} -type f 2>/dev/null | wc -l`
if [ 0 -ne $orphanFileCount ]; then
  echo "ERROR: [${DATA_SET}] Unexpected ${RAW_NAME} residual files found. Files being moved to Failure folder."

  # Move files to Failure Folder.
  mkdir -p ${FAILURE_FOLDER}/${RAW_NAME}
  # Note: Not just moving folder because there might be one already existing from prior failures.
  ${TOOL_HOME}/doCopy -fr ${RAW_FOLDER} ${FAILURE_FOLDER}
  
  ((ResidualFileFailureCount+=${orphanFileCount}))
  ExitCode=$EXIT_ERROR
  ExitMessage="Unexpected ${RAW_NAME} residual files found."
fi

# All done, clean up.
rm -rf ${RAW_FOLDER}

#
# Now look at Transform files for residual files.
#
orphanFileCount=`find ${TRANSFORM_FOLDER} -type f 2>/dev/null | wc -l`
if [ 0 -ne $orphanFileCount ]; then
  ExitCode=$EXIT_ERROR
  ExitMessage="[${DATA_SET}] Unexpected ${TRANSFORM_NAME} residual files found. Files being moved to Failure folder."
  echo "ERROR: $ExitMessage"

  # Now clean up any remaining 
  # Estimate Ingestion Failure based on Conversations
  IngestFailureCount=`find ${TRANSFORM_FOLDER} -name "${BLMIB_FNAME_PREFIX}*.xml" | wc -l`

  # Add in number of messages that failed into IngestFailureCount
  msgCount=`find ${TRANSFORM_FOLDER} -name "${BLMMSG_FNAME_PREFIX}*.xml" | wc -l`
  ((IngestFailureCount+=${msgCount}))

  # Move content to failure folder.
  mkdir -p ${FAILURE_FOLDER}/${TRANSFORM_NAME}
  # Note: Not just moving folder because there might be one already existing from prior failures.
  ${TOOL_HOME}/doCopy -fr ${TRANSFORM_FOLDER} ${FAILURE_FOLDER}

  ((ResidualFileFailureCount+=${orphanFileCount}))
fi

# Everything should either be ingested or moved to Quarantine
rm -rf ${TRANSFORM_FOLDER} 

#
# Clean up the history file
#
if [ -f "${PROCESSED_LOG}" ]; then
    # Need a temporary file to write results into
    TMP_LOG_FILE=${PROCESSED_LOG}.$$

    awk -F "," -v KEEP_DAYS=$MAX_HISTORY_IN_DAYS '
    { 
      if ( mktime($1) > systime() - (KEEP_DAYS * 24 * 60 * 60) )
          print $0;
    }' ${PROCESSED_LOG} > $TMP_LOG_FILE

    mv -f $TMP_LOG_FILE $PROCESSED_LOG
fi

# All done, report the status to where configured.
report_status $ExitCode "$ExitMessage"

echo "INFO: [${DATA_SET}] Finished Processing ($ExitCode - $ExitMessage)"
log_timestamp

exit $ExitCode
